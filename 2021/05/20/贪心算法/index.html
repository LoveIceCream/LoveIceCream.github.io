<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="随便记录">
    <meta name="author" content="我喜欢吃的是冰淇淋啊">
    
    <title>
        
            贪心算法 |
        
        冰淇淋Blog
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/icecream.jpeg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/icecream.jpeg","favicon":"/images/icecream.jpeg","article_img_align":"center","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":true},"version":"3.4.2"};
    KEEP.language_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 月前","year":"%s 年前"};
  </script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            <a class="logo-title" href="/">
                冰淇淋Blog
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                归档
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                分类
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                标签
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/gallery"
                            >
                                图册
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">归档</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">分类</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">标签</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/gallery">图册</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">贪心算法</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/icecream.jpeg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">我喜欢吃的是冰淇淋啊</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2021-05-20 19:18:18
    </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fas fa-file-word"></i>&nbsp;<span>5.7k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fas fa-clock"></i>&nbsp;<span>20 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fas fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <ul>
<li>文章列表摘要</li>
</ul>
<a id="more"></a>







<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul>
<li><p>在对问题求解的时候，只看重当前最优的情况，不保证最优解，但是在好多问题上能够得到最好的。</p>
</li>
<li><p>所谓贪心算法是指，在对问题求解时，总是<strong>做出在当前看来是最好的选择</strong>。也就是说，不从整体最优上加以考虑，它所做出的仅仅是在某种意义上的<strong>局部最优解</strong>。<br>贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性（即某个状态以后的过程不会影响以前的状态，只与当前状态有关。）<br><strong>所以，对所采用的贪心策略一定要仔细分析其是否满足无后效性。</strong></p>
</li>
<li><p>贪心算法的基本思路</p>
<ul>
<li>建立数学模型来描述问题</li>
<li>把求解的问题分成若干个子问题</li>
<li>对每个子问题求解，得到子问题的局部最优解</li>
<li>把子问题的解局部最优解合成原来问题的一个解</li>
</ul>
</li>
<li><p>该算法存在的问题</p>
<ul>
<li>不能保证求得的最后解是最佳的</li>
<li>不能用来求最大值或最小值的问题</li>
<li>只能求满足某些约束条件的可行解的范围</li>
</ul>
</li>
<li><p>贪心算法适用的问题</p>
<ul>
<li><strong>贪心策略适用的前提是：局部最优策略能导致产生全局最优解。</strong><br>实际上，贪心算法适用的情况很少。一般对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可以做出判断。</li>
</ul>
</li>
<li><p>贪心选择性质</p>
<ul>
<li>所谓贪心选择性质是指所求问题的整体最优解可以通过一系列局部最优的选择，换句话说，当考虑做何种选择的时候，我们只考虑对当前问题最佳的选择而不考虑子问题的结果。这是贪心算法可行的第一个基本要素。贪心算法以迭代的方式作出相继的贪心选择，每作一次贪心选择就将所求问题简化为规模更小的子问题。<strong>对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。</strong><br>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用贪心算法求解的关键特征。</li>
</ul>
</li>
<li><p>贪心算法的实现框架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">从问题的某一初始解出发：</span><br><span class="line">while (朝给定总目标前进一步)</span><br><span class="line">&#123;</span><br><span class="line">利用可行的决策，求出可行解的一个解元素。</span><br><span class="line">&#125;</span><br><span class="line">由所有解元素组合成问题的一个可行解；</span><br></pre></td></tr></table></figure></li>
<li><p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/tianqizhi/p/9571939.html" >https://www.cnblogs.com/tianqizhi/p/9571939.html<i class="fas fa-external-link-alt"></i></a></p>
</li>
</ul>
<h1 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1 贪心算法"></a>1 贪心算法</h1><h2 id="1-1-教室调度问题"><a href="#1-1-教室调度问题" class="headerlink" title="1.1 教室调度问题"></a>1.1 教室调度问题</h2><p>　　假设有如下课程表，你希望将尽可能多的课程安排在某间教室上。</p>
<p>　　你没法让这些课都在这间教室上，因为有些课的上课时间有冲突。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104130846794-755693956.png"
                      alt="img"
                ></p>
<p>　　你希望在这间教室上尽可能多的课。如何选出尽可能多且时间不冲突的课程呢？这个问题好像很难，不是吗？实际上，算法可能简单得让你大吃一惊。具体做法如下。<br>　　(1) 选出结束最早的课，它就是要在这间教室上的第一堂课。<br>　　(2) 接下来，必须选择第一堂课结束后才开始的课。同样，你选择结束最早的课，这将是要在这间教室上的第二堂课。重复这样做就能找出答案！下面来试一试。美术课的结束时间最早，为10:00 a.m.，因此它就是第一堂课。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104131303677-1865182050.png"
                      alt="img"
                ></p>
<p>　　接下来的课必须在10:00 a.m.后开始，且结束得最早。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104131342309-380111774.png"
                      alt="img"
                ></p>
<p>　　英语课不行，因为它的时间与美术课冲突，但数学课满足条件。最后，计算机课与数学课的时间是冲突的，但音乐课可以。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104131428045-1692213873.png"
                      alt="img"
                ></p>
<p>　　因此将在这间教室上如下三堂课。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104131458776-1127100600.png"
                      alt="img"
                ></p>
<p>　　很多人都跟我说，这个算法太容易、太显而易见，肯定不对。但这正是贪婪算法的优点——简单易行！贪婪算法很简单：每步都采取最优的做法。在这个示例中，你每次都选择结束最早的课。用专业术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。信不信由你，对于这个调度问题，上述简单算法找到的就是最优解！显然，贪婪算法并非在任何情况下都行之有效，但它易于实现！下面再来看一个例子。</p>
<h2 id="1-2-背包问题"><a href="#1-2-背包问题" class="headerlink" title="1.2 背包问题"></a>1.2 背包问题</h2><p>　　假设你是个贪婪的小偷，背着可装35磅（1磅≈0.45千克）重东西的背包，在商场伺机盗窃各种可装入背包的商品。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104131934439-414857406.png"
                      alt="img"
                ></p>
<p>　　你力图往背包中装入价值最高的商品，你会使用哪种算法呢？</p>
<p>　　同样，你采取贪婪策略，这非常简单。</p>
<p>　　(1) 盗窃可装入背包的最贵商品。<br>　　(2) 再盗窃还可装入背包的最贵商品，以此类推。</p>
<p>　　只是这次这种贪婪策略不好使了！例如，你可盗窃的商品有下面三种。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104131914087-833867110.png"
                      alt="img"
                ></p>
<p>　　你的背包可装35磅的东西。音响最贵，你把它给偷了，但背包没有空间装其他东西了。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104132135274-599754070.png"
                      alt="img"
                ></p>
<p>　　你偷到了价值3000美元的东西。且慢！如果不是偷音响，而是偷笔记本电脑和吉他，总价将为3500美元！<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104132303594-2087105764.png"
                      alt="img"
                ></p>
<p>　　在这里，贪婪策略显然不能获得最优解，但非常接近。动态规划将介绍如何找出最优解。不过小偷去购物中心行窃时，不会强求所偷东西的总价最高，只要差不多就行了。</p>
<p>　　从这个示例你得到了如下启示：在有些情况下，完美是优秀的敌人。有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。</p>
<p><strong>练习：</strong></p>
<p>1.你在一家家具公司工作，需要将家具发往全国各地，为此你需要将箱子装上卡车。每个箱子的尺寸各不相同，你需要尽可能利用每辆卡车的空间，为此你将如何选择要装上卡车的箱子呢？请设计一种贪婪算法。使用这种算法能得到最优解吗？</p>
<p>　　答：种贪婪策略是，选择可装入卡车剩余空间内的最大箱子，并重复这个过程，直到不能再装入箱子为止。使用这种算法不能得到最优解。</p>
<p>2.你要去欧洲旅行，总行程为7天。对于每个旅游胜地，你都给它分配一个价值——表示你有多想去那里看看，并估算出需要多长时间。你如何将这次旅行的价值最大化？请设计一种贪婪算法。使用这种算法能得到最优解吗？</p>
<p>　　答：不断地挑选可在余下的时间内完成的价值最大的活动，直到余下的时间不够完成任何活动为止。使用这种算法不能得到最优解。</p>
<h2 id="1-3集合覆盖问题"><a href="#1-3集合覆盖问题" class="headerlink" title="1.3集合覆盖问题"></a>1.3集合覆盖问题</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104133126889-2110611253.png"
                      alt="img"
                ></p>
<p>　　假设你办了个广播节目，要让全美50个州的听众都收听得到。为此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费用，因此你力图在尽可能少的广播台播出。现有广播台名单如下。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104133150805-1864463733.png"
                      alt="img"
                ></p>
<p>　　每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104133235360-913276552.png"
                      alt="img"
                ></p>
<p>　　如何找出覆盖全美50个州的最小广播台集合呢？听起来很容易，但其实非常难。具体方法如下。</p>
<p>　　(1) 列出每个可能的广播台集合，这被称为幂集（power set）。可能的子集有2n个。</p>
<p>　　(2) 在这些集合中，选出覆盖全美50个州的最小集合。</p>
<p>　　问题是计算每个可能的广播台子集需要很长时间。由于可能的集合有2n个，因此运行时间为O(2n)。如果广播台不多，只有5～10个，这是可行的。但如果广播台很多，结果将如何呢？随着广播台的增多，需要的时间将激增。假设你每秒可计算10个子集，所需的时间将如下。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104133615767-1526456779.png"
                      alt="img"
                ></p>
<p>　　没有任何算法可以足够快地解决这个问题！怎么办呢？</p>
<h1 id="2-近似算法"><a href="#2-近似算法" class="headerlink" title="2 近似算法"></a>2 近似算法</h1><p>　　贪婪算法可化解危机！使用下面的贪婪算法可得到非常接近的解。</p>
<p>　　(1) 选出这样一个广播台，即它覆盖了最多的未覆盖州。即便这个广播台覆盖了一些已覆盖的州，也没有关系。</p>
<p>　　(2) 重复第一步，直到覆盖了所有的州。</p>
<p>　　这是一种近似算法（approximation algorithm）。在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下：</p>
<ul>
<li>速度有多快；</li>
<li>得到的近似解与最优解的接近程度。</li>
</ul>
<p>　　贪婪算法是不错的选择，它们不仅简单，而且通常运行速度很快。在这个例子中，贪婪算法的运行时间为O(n2)，其中n为广播台数量。</p>
<p>　　下面来看看解决这个问题的代码。</p>
<h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><p>　　出于简化考虑，这里假设要覆盖的州没有那么多，广播台也没有那么多。</p>
<p>　　首先，创建一个列表，其中包含要覆盖的州。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">states_needed &#96;&#96;&#x3D;&#96; &#96;set&#96;&#96;([&#96;&#96;&quot;mt&quot;&#96;&#96;, &#96;&#96;&quot;wa&quot;&#96;&#96;, &#96;&#96;&quot;or&quot;&#96;&#96;, &#96;&#96;&quot;id&quot;&#96;&#96;, &#96;&#96;&quot;nv&quot;&#96;&#96;, &#96;&#96;&quot;ut&quot;&#96;&#96;, &#96;&#96;&quot;ca&quot;&#96;&#96;, &#96;&#96;&quot;az&quot;&#96;&#96;])</span><br></pre></td></tr></table></figure>
<p>　　我使用集合来表示要覆盖的州。集合类似于列表，只是同样的元素只能出现一次，即集合不能包含重复的元素。例如，假设你有如下列表。<br>　　&gt;&gt;&gt; arr = [1, 2, 2, 3, 3, 3] </p>
<p>　　并且你将其转换为集合。<br>　　&gt;&gt;&gt; set(arr)<br>　　set([1, 2, 3]) </p>
<p>　　在这个集合中，1、2和3都只出现一次。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104134305362-269298917.png"
                      alt="img"
                ></p>
<p>　　还需要有可供选择的广播台清单，我选择使用散列表来表示它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stations &#96;&#96;&#x3D;&#96; &#96;&#123;&#125; &#96;&#96;stations[&#96;&#96;&quot;kone&quot;&#96;&#96;] &#96;&#96;&#x3D;&#96; &#96;set&#96;&#96;([&#96;&#96;&quot;id&quot;&#96;&#96;, &#96;&#96;&quot;nv&quot;&#96;&#96;, &#96;&#96;&quot;ut&quot;&#96;&#96;]) &#96;&#96;stations[&#96;&#96;&quot;ktwo&quot;&#96;&#96;] &#96;&#96;&#x3D;&#96; &#96;set&#96;&#96;([&#96;&#96;&quot;wa&quot;&#96;&#96;, &#96;&#96;&quot;id&quot;&#96;&#96;, &#96;&#96;&quot;mt&quot;&#96;&#96;]) &#96;&#96;stations[&#96;&#96;&quot;kthree&quot;&#96;&#96;] &#96;&#96;&#x3D;&#96; &#96;set&#96;&#96;([&#96;&#96;&quot;or&quot;&#96;&#96;, &#96;&#96;&quot;nv&quot;&#96;&#96;, &#96;&#96;&quot;ca&quot;&#96;&#96;]) &#96;&#96;stations[&#96;&#96;&quot;kfour&quot;&#96;&#96;] &#96;&#96;&#x3D;&#96; &#96;set&#96;&#96;([&#96;&#96;&quot;nv&quot;&#96;&#96;, &#96;&#96;&quot;ut&quot;&#96;&#96;]) &#96;&#96;stations[&#96;&#96;&quot;kfive&quot;&#96;&#96;] &#96;&#96;&#x3D;&#96; &#96;set&#96;&#96;([&#96;&#96;&quot;ca&quot;&#96;&#96;, &#96;&#96;&quot;az&quot;&#96;&#96;]) </span><br></pre></td></tr></table></figure>
<p> 　其中的键为广播台的名称，值为广播台覆盖的州。在该示例中，广播台kone覆盖了爱达荷州、内达华州和犹他州。所有的值都是集合。你马上将看到，使用集合来表示一切可以简化工作。</p>
<p>　　最后，需要使用一个集合来存储最终选择的广播台。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final_stations &#96;&#96;&#x3D;&#96; &#96;set&#96;&#96;() </span><br></pre></td></tr></table></figure>
<h3 id="2-计算答案"><a href="#2-计算答案" class="headerlink" title="2. 计算答案"></a>2. 计算答案</h3><p>　　接下来需要计算要使用哪些广播台。根据下边的示意图，你能确定应使用哪些广播台吗？<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104134656027-555924294.png"
                      alt="img"
                ></p>
<p>　　正确的解可能有多个。你需要遍历所有的广播台，从中选择覆盖了最多的未覆盖州的广播台。我将这个广播台存储在best_station中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">best_station &#96;&#96;&#x3D;&#96; &#96;None&#96;&#96;states_covered &#96;&#96;&#x3D;&#96; &#96;set&#96;&#96;() &#96;&#96;for&#96; &#96;station, states_for_station &#96;&#96;in&#96; &#96;stations.items(): </span><br></pre></td></tr></table></figure>
<p> 　states_covered是一个集合，包含该广播台覆盖的所有未覆盖的州。for循环迭代每个广播台，并确定它是否是最佳的广播台。下面来看看这个for循环的循环体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">covered &#96;&#96;&#x3D;&#96; &#96;states_needed &amp; states_for_station &#96;&#96;#它计算交集&#96;&#96;if&#96; &#96;len&#96;&#96;(covered) &gt; &#96;&#96;len&#96;&#96;(states_covered):&#96;&#96;  &#96;&#96;best_station &#96;&#96;&#x3D;&#96; &#96;station &#96;&#96;  &#96;&#96;states_covered &#96;&#96;&#x3D;&#96; &#96;covered </span><br></pre></td></tr></table></figure>
<p>　　下面的代码计算交集。<br>　　covered = states_needed &amp; states_for_station </p>
<p>　　covered是一个集合，包含同时出现在states_needed和states_for_station中的州；换言之，它包含当前广播台覆盖的一系列还未覆盖的州！接下来，你检查该广播台覆盖的州是否比best_station多。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if&#96; &#96;len&#96;&#96;(covered) &gt; &#96;&#96;len&#96;&#96;(states_covered): &#96;&#96;  &#96;&#96;best_station &#96;&#96;&#x3D;&#96; &#96;station &#96;&#96;  &#96;&#96;states_covered &#96;&#96;&#x3D;&#96; &#96;covered</span><br></pre></td></tr></table></figure>
<p> 　如果是这样的，就将best_station设置为当前广播台。最后，你在for循环结束后将best_station添加到最终的广播台列表中。</p>
<p>　　final_stations.add(best_station)<br>　　你还需更新states_needed。由于该广播台覆盖了一些州，因此不用再覆盖这些州。<br>　　states_needed -= states_covered<br>　　你不断地循环，直到states_needed为空。这个循环的完整代码如下。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while&#96; &#96;states_needed: &#96;&#96;  &#96;&#96;best_station &#96;&#96;&#x3D;&#96; &#96;None&#96;&#96;  &#96;&#96;states_covered &#96;&#96;&#x3D;&#96; &#96;set&#96;&#96;() &#96;&#96;  &#96;&#96;for&#96; &#96;station, states &#96;&#96;in&#96; &#96;stations.items(): &#96;&#96;    &#96;&#96;covered &#96;&#96;&#x3D;&#96; &#96;states_needed &amp; states &#96;&#96;    &#96;&#96;if&#96; &#96;len&#96;&#96;(covered) &gt; &#96;&#96;len&#96;&#96;(states_covered): &#96;&#96;      &#96;&#96;best_station &#96;&#96;&#x3D;&#96; &#96;station &#96;&#96;      &#96;&#96;states_covered &#96;&#96;&#x3D;&#96; &#96;covered  &#96; &#96;states_needed &#96;&#96;-&#96;&#96;&#x3D;&#96; &#96;states_covered &#96;&#96;finalstations.add(beststation)  </span><br></pre></td></tr></table></figure>
<p>　　 最后，你打印final_stations，结果类似于下面这样。<br>　　&gt;&gt;&gt; print final_stations<br>　　set([‘ktwo’, ‘kthree’, ‘kone’, ‘kfive’])<br>　　结果符合你的预期吗？选择的广播台可能是2、3、4和5，而不是预期的1、2、3和5。下面来比较一下贪婪算法和精确算法的运行时间。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104171323567-1155864300.png"
                      alt="img"
                ></p>
<p> 注：快速排序属于分治算法，广度优先搜索和狄克斯特拉算法属于贪婪算法。</p>
<h2 id="2-1-NP-完全问题"><a href="#2-1-NP-完全问题" class="headerlink" title="2.1 NP 完全问题"></a>2.1 NP 完全问题</h2><p>　　为解决集合覆盖问题，你必须计算每个可能的集合。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104172914804-1250493792.png"
                      alt="img"
                ></p>
<p>　　这可能让你想起了旅行商问题。在这个问题中，旅行商需要前往5个不同的城市。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104173144261-2038883313.png"
                      alt="img"
                ></p>
<p>　　他需要找出前往这5个城市的最短路径，为此，必须计算每条可能的路径。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104173226217-1865829439.png"
                      alt="img"
                ></p>
<p>　　前往5个城市时，可能的路径有多少条呢？</p>
<h3 id="旅行商问题详解"><a href="#旅行商问题详解" class="headerlink" title="旅行商问题详解:"></a>旅行商问题详解:</h3><p>　　我们从城市数较少的情况着手。假设只涉及两个城市，因此可供选择的路线有两条。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104173407124-18714690.png"
                      alt="img"
                ></p>
<p>　　<strong>这两条路线相同还是不同?</strong></p>
<p>　　你可能认为这两条路线相同，难道从旧金山到马林的距离与从马林到旧金山的距离不同吗？不一定。有些城市（如旧金山）有很多单行线，因此你无法按原路返回。你可能需要离开原路行驶一两英里才能找到上高速的匝道。因此，这两条路线不一定相同。</p>
<p>　　你可能心存疑惑：在旅行商问题中，必须从特定的城市出发吗？例如，假设我是旅行商。我居住在旧金山，需要前往其他4个城市，因此我将从旧金山出发。</p>
<p>　　但有时候，不确定要从哪个城市出发。假设联邦快递将包裹从芝加哥发往湾区，包裹将通过航运发送到联邦快递在湾区的50个集散点之一，再装上经过不同配送点的卡车。该通过航运发送到哪个集散点呢？在这个例子中，起点就是未知的。因此，你需要通过计算为旅行商找出起点和最佳路线。</p>
<p>　　在这两种情况下，运行时间是相同的。但出发城市未定时更容易处理，因此这里以这种情况为例。</p>
<p>　　涉及两个城市时，可能的路线有两条。</p>
<p>　　现在假设再增加一个城市，可能的路线有多少条呢？如果从伯克利出发，就需前往另外两个城市。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104173727005-981559710.png"
                      alt="img"
                ></p>
<p>　　从每个城市出发时，都有两条不同的路线，因此总共有6条路线。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104173810449-1661773052.png"
                      alt="img"
                ></p>
<p>　　因此涉及3个城市时，可能的路线有6条。</p>
<p>　　我们再增加一个城市——弗里蒙特。现在假设从弗里蒙特出发。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104173857311-1107799382.png"
                      alt="img"
                ></p>
<p>　　从弗里蒙特出发时，有6条可能的路线。这些路线与前面只有3个城市时计算的6条路线很像，只是现在所有的路线都多了一个城市——弗里蒙特！这里有一个规律。假设有4个城市，你选择一个出发城市——弗里蒙特后，还余下3个城市。而你知道，涉及3个城市时，可能的路线有6条。从弗里蒙特出发时，有6条可能的路线，但还可以从其他任何一个城市出发。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104174851244-1868602611.png"
                      alt="img"
                ></p>
<p>　　可能的出发城市有4个，从每个城市出发时都有6条可能的路线，因此可能的路线有4 × 6 = 24条。你看出规律了吗？每增加一个城市，需要计算的路线数都将增加。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104174945344-1476164878.png"
                      alt="img"
                ></p>
<p>　　涉及6个城市时，可能的路线有多少条呢？如果你说720条，那就对了。7个城市为5040条，8个城市为40320条。</p>
<p>　　这被称为阶乘函数（factorial function），假设有10个城市，可能的路线有多少条呢？10! = 3 628 800。换句话说，涉及10个城市时，需要计算的可能路线超过300万条。正如你看到的，可能的路线数增加得非常快！因此，如果涉及的城市很多，根本就无法找出旅行商问题的正确解。</p>
<p>　　旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。</p>
<p><strong>近似求解:</strong></p>
<p>　　对旅行商问题来说，什么样的近似算法不错呢？能找到较短路径的算法就算不错。在继续往下阅读前，看看你能设计出这样的算法吗？</p>
<p>　　我会采取这样的做法：随便选择出发城市，然后每次选择要去的下一个城市时，都选择还没去的最近的城市。假设旅行商从马林出发。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104175302022-1681617029.png"
                      alt="img"
                ></p>
<p>　　总旅程为71英里。这条路径可能不是最短的，但也相当短了。</p>
<p>　　NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。</p>
<h2 id="2-2-如何识别-NP-完全问题"><a href="#2-2-如何识别-NP-完全问题" class="headerlink" title="2.2 如何识别 NP 完全问题"></a>2.2 如何识别 NP 完全问题</h2><p>　　Jonah正为其虚构的橄榄球队挑选队员。他列了一个清单，指出了对球队的要求：优秀的四分卫，优秀的跑卫，擅长雨中作战，以及能承受压力等。他有一个候选球员名单，其中每个球员都满足某些要求。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104175530468-307544311.png"
                      alt="img"
                ></p>
<p>　　Jonah需要组建一个满足所有这些要求的球队，可名额有限。等等，Jonah突然间意识到，这不就是一个集合覆盖问题吗！<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104175610938-1170024570.png"
                      alt="img"
                ></p>
<p>　　Jonah可使用前面介绍的近似算法来组建球队。</p>
<p>　　(1) 找出符合最多要求的球员。</p>
<p>　　(2) 不断重复这个过程，直到球队满足要求（或球队名额已满）。</p>
<p>　　NP完全问题无处不在！如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。例如，前一章深入讨论了最短路径，你知道如何找出从A点到B点的最短路径。<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://img2018.cnblogs.com/blog/1286166/201811/1286166-20181104175811110-73485942.png"
                      alt="img"
                ></p>
<p>　　但如果要找出经由指定几个点的的最短路径，就是旅行商问题——NP完全问题。简言之，没办法判断问题是不是NP完全问题，但还是有一些蛛丝马迹可循的。</p>
<ul>
<li>元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。</li>
<li>涉及“所有组合”的问题通常是NP完全问题。</li>
<li>不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。</li>
<li>如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。</li>
<li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。</li>
<li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。</li>
</ul>
<p><strong>练习：</strong></p>
<p>1.有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径。请问这是一个NP完全问题吗？是的<br>2.在一堆人中找出最大的朋友圈（即其中任何两个人都相识）是NP完全问题吗？是的<br>3.你要制作美国地图，需要用不同的颜色标出相邻的州。为此，你需要确定最少需要使用多少种颜色，才能确保任何两个相邻州的颜色都不同。请问这是NP完全问题吗？是的</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul>
<li>贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。</li>
<li>对于NP完全问题，还没有找到快速解决方案。</li>
<li>面临NP完全问题时，最佳的做法是使用近似算法。</li>
<li>贪婪算法易于实现、运行速度快，是不错的近似算法。</li>
</ul>

        </div>

        
            <div class="post-copyright-info">
                <div class="article-copyright-info-container">
    <ul>
        <li>本文标题：贪心算法</li>
        <li>本文作者：我喜欢吃的是冰淇淋啊</li>
        <li>创建时间：2021-05-20 19:18:18</li>
        <li>
            本文链接：https://loveicecream.github.io/2021/05/20/贪心算法/
        </li>
        <li>
            版权声明：本博客所有文章除特别声明外，均采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">BY-NC-SA</a> 许可协议。转载请注明出处！
        </li>
    </ul>
</div>

            </div>
        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/05/20/%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">搜索算法</span>
                                <span class="post-nav-item">上一篇</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/2021/05/20/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">动态规划</span>
                                <span class="post-nav-item">下一篇</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">我喜欢吃的是冰淇淋啊</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                
                    <span id="busuanzi_container_site_pv">
                        总访问量&nbsp;<span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="theme-info info-item">
            由 <a target="_blank" href="https://hexo.io">Hexo</a> 驱动&nbsp;|&nbsp;主题&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.2</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">贪心算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">1 贪心算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%95%99%E5%AE%A4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">1.1 教室调度问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">1.2 背包问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">1.3集合覆盖问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95"><span class="nav-number"></span> <span class="nav-text">2 近似算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">1.</span> <span class="nav-text">1. 准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%AE%A1%E7%AE%97%E7%AD%94%E6%A1%88"><span class="nav-number">2.</span> <span class="nav-text">2. 计算答案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-NP-%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">2.1 NP 完全问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3"><span class="nav-number">1.</span> <span class="nav-text">旅行商问题详解:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB-NP-%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number"></span> <span class="nav-text">2.2 如何识别 NP 完全问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number"></span> <span class="nav-text">小结</span></a>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="搜索..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/lazyload.js"></script>


<div class="post-scripts">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.2/source/js/toc.js"></script>
    
</div>



</body>
</html>
